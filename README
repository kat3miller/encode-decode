This is a program that encodes and decodes a file using huffman coding.

To compile this program, type make all.

To encode a file, type ./encode -i nameOfFileToEncode
By default, encode will write to standard out so to specify an output file, use flag -o followed by the name of the file.

ex: ./encode -i nameOfFileToEncode -o encodedFile

To decode the file, type -i encodedFile
Decode also writes to standard out by default so the -o flag followed by the name you want for the decoded file will also work.

ex: ./decode -i encodedFile -i decodedFile

To remove encode and decode, type make clean.



My partner and I worked together to come up with the design. Some parts of the program were written by the professor which I specified in the comments. 
 
In encode we first created a histogram which is an array of size 256 which stores the frequency of each symbol. Then encode reads in the file, gets its stats, then increments the frequency in the histogram every time it comes across a character. The file gets closed and then we build our queue. 

Our queue is an array that stores the frequency and a pointer to an item in each index. In order to accomplish this I made a struct containing these two things and made an array of these structs. Every time something gets put in the queue we put it in the end of the queue and then do insertion sort on it to keep it in descending order. 

We then use our histogram to put things in the queue. When there is a frequency greater than or equal to one we put it in the queue and it gets sorted. Then we begin to join the two elements(treenodes) with the lowest frequency continuously until there is only one element in the queue. That element is our root.

Next we build our codes with buildcode which recursively calls itself to push the correct path of the characters into a code. Since the codes are in the opposite order we made another code table which stores the reverse of our first code table.

Next we wrote the magic number, file size, and tree size to our output. Then we wrote our tree to the file using dumpTree. We open our text file again so we can use it to get the codes we need. We make a bit vector which gets set according to the code and then gets written to the output once it gets full. This repeats until we finish writing to the file. Once it’s done we free everything.
 

Next in decode we read in the encrypted file and read and save the magic number, the filesize, the tree size, and the saved tree. If the magic number doesn’t match we quit. Next we call loadtree which uses the saved tree and tree size to reconstruct the tree created in enqueue.

Then a char array the same size as filesize gets created which will store all of the decoded characters. Then we read in bytes, create a bitvector of that amount times 8, then put those bytes into the bit vector. Then we loop through the bitvector and use the tree to step through until our pointer to the tree hits a leaf. 

Once a leaf is hit it is put in our array and the pointer points back to the root. This is all repeated until we stop reading in bytes. Once this is done we write either to standard out or to the output file according to what the user specified using the array we stored the characters in. Then we free and close stuff and it’s done.
 
This was very much a team effort. I was in charge of decode while my partner was in charge of encode and we worked on developing the data structures together.

 
I developed a lot of the structure of queue and getting enqueue and dequeue to work. I wrote most of the histogram. My partner got dumpTree to work, got the initial structure set up, and did most of buildCode. We worked together to write loadTree so there was equal work on that. I wrote most of the code in decode and she wrote most of the code in encode. 
